// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for GetCheckoutSessionsResponseDataStatus.
const (
	GetCheckoutSessionsResponseDataStatusComplete GetCheckoutSessionsResponseDataStatus = "complete"
	GetCheckoutSessionsResponseDataStatusExpired  GetCheckoutSessionsResponseDataStatus = "expired"
	GetCheckoutSessionsResponseDataStatusOpen     GetCheckoutSessionsResponseDataStatus = "open"
)

// Defines values for InvoiceDataStatus.
const (
	InvoiceDataStatusDraft         InvoiceDataStatus = "draft"
	InvoiceDataStatusOpen          InvoiceDataStatus = "open"
	InvoiceDataStatusPaid          InvoiceDataStatus = "paid"
	InvoiceDataStatusUncollectible InvoiceDataStatus = "uncollectible"
	InvoiceDataStatusVoid          InvoiceDataStatus = "void"
)

// Defines values for GetCheckoutSessionsParamsStatus.
const (
	GetCheckoutSessionsParamsStatusComplete GetCheckoutSessionsParamsStatus = "complete"
	GetCheckoutSessionsParamsStatusExpired  GetCheckoutSessionsParamsStatus = "expired"
	GetCheckoutSessionsParamsStatusOpen     GetCheckoutSessionsParamsStatus = "open"
)

// Defines values for GetInvoicesParamsStatus.
const (
	GetInvoicesParamsStatusDraft         GetInvoicesParamsStatus = "draft"
	GetInvoicesParamsStatusOpen          GetInvoicesParamsStatus = "open"
	GetInvoicesParamsStatusPaid          GetInvoicesParamsStatus = "paid"
	GetInvoicesParamsStatusUncollectible GetInvoicesParamsStatus = "uncollectible"
	GetInvoicesParamsStatusVoid          GetInvoicesParamsStatus = "void"
)

// Defines values for GetInvoicesParamsCollectionMethod.
const (
	ChargeAutomatically GetInvoicesParamsCollectionMethod = "charge_automatically"
	SendInvoice         GetInvoicesParamsCollectionMethod = "send_invoice"
)

// Admin 管理者の情報
type Admin struct {
	// Id traQ ID
	Id string `json:"id"`
}

// Customer Customer の情報
type Customer struct {
	// Email Email
	Email *string `json:"email,omitempty"`

	// Id Customer ID
	Id *string `json:"id,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// TraqId traQ ID
	TraqId *string `json:"traq_id,omitempty"`
}

// GetCheckoutSessionsResponse オンライン決済ページ由来の入金一覧
type GetCheckoutSessionsResponse struct {
	Data *[]struct {
		// AmountSubtotal 割引・税金を含まない支払い金額
		AmountSubtotal *int `json:"amount_subtotal,omitempty"`

		// AmountTotal 支払い金額
		AmountTotal *int `json:"amount_total,omitempty"`

		// Created 作成日時 (Unix 時間)
		Created *int `json:"created,omitempty"`

		// Customer Customer の情報
		Customer *Customer `json:"customer,omitempty"`

		// Id Checkout Session ID
		Id *string `json:"id,omitempty"`

		// PaymentIntent この Checkout Session に関連付けられた PaymentIntent
		PaymentIntent *string `json:"payment_intent,omitempty"`

		// ProductId Product ID
		ProductId *string `json:"product_id,omitempty"`

		// Status Checkout Session のステータス
		Status *GetCheckoutSessionsResponseDataStatus `json:"status,omitempty"`
	} `json:"data,omitempty"`

	// HasMore 次のページがあるか
	HasMore *bool `json:"has_more,omitempty"`
}

// GetCheckoutSessionsResponseDataStatus Checkout Session のステータス
type GetCheckoutSessionsResponseDataStatus string

// Invoice Invoice の情報
type Invoice struct {
	Data *[]struct {
		// AmountDue 最終的に支払う金額
		AmountDue *int `json:"amount_due,omitempty"`

		// AmountPaid 支払い済み金額
		AmountPaid *int `json:"amount_paid,omitempty"`

		// AmountRemaining 支払い残高
		AmountRemaining *int `json:"amount_remaining,omitempty"`

		// Created 作成日時 (Unix 時間)
		Created *int `json:"created,omitempty"`

		// Customer Customer の情報
		Customer *Customer `json:"customer,omitempty"`

		// Id Invoice ID
		Id *string `json:"id,omitempty"`

		// PaymentIntent この請求書に関連付けられた PaymentIntent
		PaymentIntent *string `json:"payment_intent,omitempty"`

		// ProductId Product ID
		ProductId *string `json:"product_id,omitempty"`

		// Status 請求書ステータス
		Status *InvoiceDataStatus `json:"status,omitempty"`
	} `json:"data,omitempty"`

	// HasMore 次のページがあるか
	HasMore *bool `json:"has_more,omitempty"`
}

// InvoiceDataStatus 請求書ステータス
type InvoiceDataStatus string

// PostCustomerRequest Customer 作成リクエスト
type PostCustomerRequest struct {
	// Email Email
	Email string `json:"email"`

	// Name Name
	Name string `json:"name"`

	// TraqId traQ ID
	TraqId *string `json:"traq_id,omitempty"`
}

// PostInvoiceRequest Invoice 作成リクエスト
type PostInvoiceRequest struct {
	// CustomerId Customer ID
	CustomerId string `json:"customer_id"`

	// ProductId Product ID
	ProductId string `json:"product_id"`
}

// CustomerId defines model for CustomerId.
type CustomerId = string

// EndingBefore defines model for EndingBefore.
type EndingBefore = string

// Limit defines model for Limit.
type Limit = int

// StartingAfter defines model for StartingAfter.
type StartingAfter = string

// SubscriptionId defines model for SubscriptionId.
type SubscriptionId = string

// DeleteAdminParams defines parameters for DeleteAdmin.
type DeleteAdminParams struct {
	// Id 管理者の traQ ID
	Id string `form:"id" json:"id"`
}

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
	// CustomerId Customer ID
	CustomerId *CustomerId `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// TraqId traQ ID
	TraqId *string `form:"traq_id,omitempty" json:"traq_id,omitempty"`

	// Email Email
	Email *string `form:"email,omitempty" json:"email,omitempty"`
}

// GetCheckoutSessionsParams defines parameters for GetCheckoutSessions.
type GetCheckoutSessionsParams struct {
	// CustomerId Customer ID
	CustomerId *CustomerId `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// SubscriptionId Subscription ID
	SubscriptionId *SubscriptionId `form:"subscription_id,omitempty" json:"subscription_id,omitempty"`

	// Limit 取得件数
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter 指定された ID のオブジェクト以降のオブジェクトを取得
	StartingAfter *StartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore 指定された ID のオブジェクト以前のオブジェクトを取得
	EndingBefore *EndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// PaymentIntentId PaymentIntent ID
	PaymentIntentId *string `form:"payment_intent_id,omitempty" json:"payment_intent_id,omitempty"`

	// Status Checkout Session のステータス
	Status *GetCheckoutSessionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetCheckoutSessionsParamsStatus defines parameters for GetCheckoutSessions.
type GetCheckoutSessionsParamsStatus string

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {
	// CustomerId Customer ID
	CustomerId *CustomerId `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// SubscriptionId Subscription ID
	SubscriptionId *SubscriptionId `form:"subscription_id,omitempty" json:"subscription_id,omitempty"`

	// Limit 取得件数
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter 指定された ID のオブジェクト以降のオブジェクトを取得
	StartingAfter *StartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore 指定された ID のオブジェクト以前のオブジェクトを取得
	EndingBefore *EndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Status 請求書ステータス
	Status *GetInvoicesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// CollectionMethod 請求書の支払い方法
	CollectionMethod *GetInvoicesParamsCollectionMethod `form:"collection_method,omitempty" json:"collection_method,omitempty"`
}

// GetInvoicesParamsStatus defines parameters for GetInvoices.
type GetInvoicesParamsStatus string

// GetInvoicesParamsCollectionMethod defines parameters for GetInvoices.
type GetInvoicesParamsCollectionMethod string

// PostWebhookInvoicePaidParams defines parameters for PostWebhookInvoicePaid.
type PostWebhookInvoicePaidParams struct {
	// StripeSignature Stripe が送信する認証情報
	StripeSignature string `json:"Stripe-Signature"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = Admin

// PatchCustomerJSONRequestBody defines body for PatchCustomer for application/json ContentType.
type PatchCustomerJSONRequestBody = PostCustomerRequest

// PostCustomerJSONRequestBody defines body for PostCustomer for application/json ContentType.
type PostCustomerJSONRequestBody = PostCustomerRequest

// PostInvoiceJSONRequestBody defines body for PostInvoice for application/json ContentType.
type PostInvoiceJSONRequestBody = PostInvoiceRequest

// PostWebhookInvoicePaidJSONRequestBody defines body for PostWebhookInvoicePaid for application/json ContentType.
type PostWebhookInvoicePaidJSONRequestBody = Invoice

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 管理者を削除
	// (DELETE /admin)
	DeleteAdmin(ctx echo.Context, params DeleteAdminParams) error
	// 管理者の一覧を取得
	// (GET /admin)
	GetAdmins(ctx echo.Context) error
	// 管理者を作成
	// (POST /admin)
	PostAdmin(ctx echo.Context) error
	// Customer を取得
	// (GET /customer)
	GetCustomer(ctx echo.Context, params GetCustomerParams) error
	// Customer を更新
	// (PATCH /customer)
	PatchCustomer(ctx echo.Context) error
	// Customer を作成
	// (POST /customer)
	PostCustomer(ctx echo.Context) error
	// Invoice を作成
	// (POST /invoice)
	PostInvoice(ctx echo.Context) error
	// オンライン決済ページ由来の入金一覧を取得
	// (GET /list/checkout-sessions)
	GetCheckoutSessions(ctx echo.Context, params GetCheckoutSessionsParams) error
	// 請求書由来の入金一覧を取得
	// (GET /list/invoices)
	GetInvoices(ctx echo.Context, params GetInvoicesParams) error
	// Webhook の invoice.paid イベントを受け取る
	// (POST /webhook/invoice-paid)
	PostWebhookInvoicePaid(ctx echo.Context, params PostWebhookInvoicePaidParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAdminParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, params)
	return err
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomerParams
	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "traq_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "traq_id", ctx.QueryParams(), &params.TraqId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCustomer(ctx, params)
	return err
}

// PatchCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) PatchCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchCustomer(ctx)
	return err
}

// PostCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCustomer(ctx)
	return err
}

// PostInvoice converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvoice(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostInvoice(ctx)
	return err
}

// GetCheckoutSessions converts echo context to params.
func (w *ServerInterfaceWrapper) GetCheckoutSessions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCheckoutSessionsParams
	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "subscription_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_id", ctx.QueryParams(), &params.SubscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "starting_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "starting_after", ctx.QueryParams(), &params.StartingAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starting_after: %s", err))
	}

	// ------------- Optional query parameter "ending_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "ending_before", ctx.QueryParams(), &params.EndingBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ending_before: %s", err))
	}

	// ------------- Optional query parameter "payment_intent_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "payment_intent_id", ctx.QueryParams(), &params.PaymentIntentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_intent_id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCheckoutSessions(ctx, params)
	return err
}

// GetInvoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoices(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvoicesParams
	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "subscription_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_id", ctx.QueryParams(), &params.SubscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "starting_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "starting_after", ctx.QueryParams(), &params.StartingAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starting_after: %s", err))
	}

	// ------------- Optional query parameter "ending_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "ending_before", ctx.QueryParams(), &params.EndingBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ending_before: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "collection_method" -------------

	err = runtime.BindQueryParameter("form", true, false, "collection_method", ctx.QueryParams(), &params.CollectionMethod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_method: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInvoices(ctx, params)
	return err
}

// PostWebhookInvoicePaid converts echo context to params.
func (w *ServerInterfaceWrapper) PostWebhookInvoicePaid(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostWebhookInvoicePaidParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "Stripe-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Stripe-Signature")]; found {
		var StripeSignature string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Stripe-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Stripe-Signature", valueList[0], &StripeSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Stripe-Signature: %s", err))
		}

		params.StripeSignature = StripeSignature
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Stripe-Signature is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostWebhookInvoicePaid(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE(baseURL+"/admin", wrapper.DeleteAdmin)
	router.GET(baseURL+"/admin", wrapper.GetAdmins)
	router.POST(baseURL+"/admin", wrapper.PostAdmin)
	router.GET(baseURL+"/customer", wrapper.GetCustomer)
	router.PATCH(baseURL+"/customer", wrapper.PatchCustomer)
	router.POST(baseURL+"/customer", wrapper.PostCustomer)
	router.POST(baseURL+"/invoice", wrapper.PostInvoice)
	router.GET(baseURL+"/list/checkout-sessions", wrapper.GetCheckoutSessions)
	router.GET(baseURL+"/list/invoices", wrapper.GetInvoices)
	router.POST(baseURL+"/webhook/invoice-paid", wrapper.PostWebhookInvoicePaid)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
