// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for GetCheckoutSessionsResponseDataStatus.
const (
	GetCheckoutSessionsResponseDataStatusComplete GetCheckoutSessionsResponseDataStatus = "complete"
	GetCheckoutSessionsResponseDataStatusExpired  GetCheckoutSessionsResponseDataStatus = "expired"
	GetCheckoutSessionsResponseDataStatusOpen     GetCheckoutSessionsResponseDataStatus = "open"
)

// Defines values for InvoiceDataStatus.
const (
	InvoiceDataStatusDraft         InvoiceDataStatus = "draft"
	InvoiceDataStatusOpen          InvoiceDataStatus = "open"
	InvoiceDataStatusPaid          InvoiceDataStatus = "paid"
	InvoiceDataStatusUncollectible InvoiceDataStatus = "uncollectible"
	InvoiceDataStatusVoid          InvoiceDataStatus = "void"
)

// Defines values for GetCheckoutSessionsParamsStatus.
const (
	GetCheckoutSessionsParamsStatusComplete GetCheckoutSessionsParamsStatus = "complete"
	GetCheckoutSessionsParamsStatusExpired  GetCheckoutSessionsParamsStatus = "expired"
	GetCheckoutSessionsParamsStatusOpen     GetCheckoutSessionsParamsStatus = "open"
)

// Defines values for GetInvoicesParamsStatus.
const (
	GetInvoicesParamsStatusDraft         GetInvoicesParamsStatus = "draft"
	GetInvoicesParamsStatusOpen          GetInvoicesParamsStatus = "open"
	GetInvoicesParamsStatusPaid          GetInvoicesParamsStatus = "paid"
	GetInvoicesParamsStatusUncollectible GetInvoicesParamsStatus = "uncollectible"
	GetInvoicesParamsStatusVoid          GetInvoicesParamsStatus = "void"
)

// Defines values for GetInvoicesParamsCollectionMethod.
const (
	ChargeAutomatically GetInvoicesParamsCollectionMethod = "charge_automatically"
	SendInvoice         GetInvoicesParamsCollectionMethod = "send_invoice"
)

// Customer Customer の情報
type Customer struct {
	// Email Email
	Email *string `json:"email,omitempty"`

	// Id Customer ID
	Id *string `json:"id,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// TraqId traQ ID
	TraqId *string `json:"traq_id,omitempty"`
}

// GetCheckoutSessionsResponse オンライン決済ページ由来の入金一覧
type GetCheckoutSessionsResponse struct {
	Data *[]struct {
		// AmountSubtotal 割引・税金を含まない支払い金額
		AmountSubtotal *int `json:"amount_subtotal,omitempty"`

		// AmountTotal 支払い金額
		AmountTotal *int `json:"amount_total,omitempty"`

		// Created 作成日時 (Unix 時間)
		Created *int `json:"created,omitempty"`

		// Customer Customer の情報
		Customer *Customer `json:"customer,omitempty"`

		// Id Checkout Session ID
		Id *string `json:"id,omitempty"`

		// PaymentIntent この Checkout Session に関連付けられた PaymentIntent
		PaymentIntent *string `json:"payment_intent,omitempty"`

		// ProductId Product ID
		ProductId *string `json:"product_id,omitempty"`

		// Status Checkout Session のステータス
		Status *GetCheckoutSessionsResponseDataStatus `json:"status,omitempty"`
	} `json:"data,omitempty"`

	// HasMore 次のページがあるか
	HasMore *bool `json:"has_more,omitempty"`
}

// GetCheckoutSessionsResponseDataStatus Checkout Session のステータス
type GetCheckoutSessionsResponseDataStatus string

// Invoice 請求書由来の入金一覧
type Invoice struct {
	Data *[]struct {
		// AmountDue 最終的に支払う金額
		AmountDue *int `json:"amount_due,omitempty"`

		// AmountPaid 支払い済み金額
		AmountPaid *int `json:"amount_paid,omitempty"`

		// AmountRemaining 支払い残高
		AmountRemaining *int `json:"amount_remaining,omitempty"`

		// Created 作成日時 (Unix 時間)
		Created *int `json:"created,omitempty"`

		// Customer Customer の情報
		Customer *Customer `json:"customer,omitempty"`

		// Id Invoice ID
		Id *string `json:"id,omitempty"`

		// PaymentIntent この請求書に関連付けられた PaymentIntent
		PaymentIntent *string `json:"payment_intent,omitempty"`

		// ProductId Product ID
		ProductId *string `json:"product_id,omitempty"`

		// Status 請求書ステータス
		Status *InvoiceDataStatus `json:"status,omitempty"`
	} `json:"data,omitempty"`

	// HasMore 次のページがあるか
	HasMore *bool `json:"has_more,omitempty"`
}

// InvoiceDataStatus 請求書ステータス
type InvoiceDataStatus string

// PostCustomerRequest Customer 作成リクエスト
type PostCustomerRequest struct {
	// Email Email
	Email string `json:"email"`

	// Name Name
	Name string `json:"name"`

	// TraqId traQ ID
	TraqId *string `json:"traq_id,omitempty"`
}

// PostInvoiceRequest Invoice 作成リクエスト
type PostInvoiceRequest struct {
	// CustomerId Customer ID
	CustomerId string `json:"customer_id"`

	// ProductId Product ID
	ProductId string `json:"product_id"`
}

// CustomerId defines model for CustomerId.
type CustomerId = string

// EndingBefore defines model for EndingBefore.
type EndingBefore = string

// Limit defines model for Limit.
type Limit = int

// StartingAfter defines model for StartingAfter.
type StartingAfter = string

// SubscriptionId defines model for SubscriptionId.
type SubscriptionId = string

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
	// CustomerId Customer ID
	CustomerId *CustomerId `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// TraqId traQ ID
	TraqId *string `form:"traq_id,omitempty" json:"traq_id,omitempty"`

	// Email Email
	Email *string `form:"email,omitempty" json:"email,omitempty"`
}

// GetCheckoutSessionsParams defines parameters for GetCheckoutSessions.
type GetCheckoutSessionsParams struct {
	// CustomerId Customer ID
	CustomerId *CustomerId `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// SubscriptionId Subscription ID
	SubscriptionId *SubscriptionId `form:"subscription_id,omitempty" json:"subscription_id,omitempty"`

	// Limit 取得件数
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter 指定された ID のオブジェクト以降のオブジェクトを取得
	StartingAfter *StartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore 指定された ID のオブジェクト以前のオブジェクトを取得
	EndingBefore *EndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// PaymentIntentId PaymentIntent ID
	PaymentIntentId *string `form:"payment_intent_id,omitempty" json:"payment_intent_id,omitempty"`

	// Status Checkout Session のステータス
	Status *GetCheckoutSessionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetCheckoutSessionsParamsStatus defines parameters for GetCheckoutSessions.
type GetCheckoutSessionsParamsStatus string

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {
	// CustomerId Customer ID
	CustomerId *CustomerId `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// SubscriptionId Subscription ID
	SubscriptionId *SubscriptionId `form:"subscription_id,omitempty" json:"subscription_id,omitempty"`

	// Limit 取得件数
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter 指定された ID のオブジェクト以降のオブジェクトを取得
	StartingAfter *StartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore 指定された ID のオブジェクト以前のオブジェクトを取得
	EndingBefore *EndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Status 請求書ステータス
	Status *GetInvoicesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// CollectionMethod 請求書の支払い方法
	CollectionMethod *GetInvoicesParamsCollectionMethod `form:"collection_method,omitempty" json:"collection_method,omitempty"`
}

// GetInvoicesParamsStatus defines parameters for GetInvoices.
type GetInvoicesParamsStatus string

// GetInvoicesParamsCollectionMethod defines parameters for GetInvoices.
type GetInvoicesParamsCollectionMethod string

// PostWebhookInvoicePaidParams defines parameters for PostWebhookInvoicePaid.
type PostWebhookInvoicePaidParams struct {
	// StripeSignature Stripe が送信する認証情報
	StripeSignature string `json:"Stripe-Signature"`
}

// PatchCustomerJSONRequestBody defines body for PatchCustomer for application/json ContentType.
type PatchCustomerJSONRequestBody = PostCustomerRequest

// PostCustomerJSONRequestBody defines body for PostCustomer for application/json ContentType.
type PostCustomerJSONRequestBody = PostCustomerRequest

// PostInvoiceJSONRequestBody defines body for PostInvoice for application/json ContentType.
type PostInvoiceJSONRequestBody = PostInvoiceRequest

// PostWebhookInvoicePaidJSONRequestBody defines body for PostWebhookInvoicePaid for application/json ContentType.
type PostWebhookInvoicePaidJSONRequestBody = Invoice

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Customer を取得
	// (GET /customer)
	GetCustomer(ctx echo.Context, params GetCustomerParams) error
	// Customer を更新
	// (PATCH /customer)
	PatchCustomer(ctx echo.Context) error
	// Customer を作成
	// (POST /customer)
	PostCustomer(ctx echo.Context) error
	// Invoice を作成
	// (POST /invoice)
	PostInvoice(ctx echo.Context) error
	// オンライン決済ページ由来の入金一覧を取得
	// (GET /list/checkout-sessions)
	GetCheckoutSessions(ctx echo.Context, params GetCheckoutSessionsParams) error
	// 請求書由来の入金一覧を取得
	// (GET /list/invoices)
	GetInvoices(ctx echo.Context, params GetInvoicesParams) error
	// Webhook の invoice.paid イベントを受け取る
	// (POST /webhook/invoice-paid)
	PostWebhookInvoicePaid(ctx echo.Context, params PostWebhookInvoicePaidParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomerParams
	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "traq_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "traq_id", ctx.QueryParams(), &params.TraqId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter traq_id: %s", err))
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCustomer(ctx, params)
	return err
}

// PatchCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) PatchCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchCustomer(ctx)
	return err
}

// PostCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCustomer(ctx)
	return err
}

// PostInvoice converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvoice(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostInvoice(ctx)
	return err
}

// GetCheckoutSessions converts echo context to params.
func (w *ServerInterfaceWrapper) GetCheckoutSessions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCheckoutSessionsParams
	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "subscription_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_id", ctx.QueryParams(), &params.SubscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "starting_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "starting_after", ctx.QueryParams(), &params.StartingAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starting_after: %s", err))
	}

	// ------------- Optional query parameter "ending_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "ending_before", ctx.QueryParams(), &params.EndingBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ending_before: %s", err))
	}

	// ------------- Optional query parameter "payment_intent_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "payment_intent_id", ctx.QueryParams(), &params.PaymentIntentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_intent_id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCheckoutSessions(ctx, params)
	return err
}

// GetInvoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoices(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvoicesParams
	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "subscription_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_id", ctx.QueryParams(), &params.SubscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "starting_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "starting_after", ctx.QueryParams(), &params.StartingAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starting_after: %s", err))
	}

	// ------------- Optional query parameter "ending_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "ending_before", ctx.QueryParams(), &params.EndingBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ending_before: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "collection_method" -------------

	err = runtime.BindQueryParameter("form", true, false, "collection_method", ctx.QueryParams(), &params.CollectionMethod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_method: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInvoices(ctx, params)
	return err
}

// PostWebhookInvoicePaid converts echo context to params.
func (w *ServerInterfaceWrapper) PostWebhookInvoicePaid(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostWebhookInvoicePaidParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "Stripe-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Stripe-Signature")]; found {
		var StripeSignature string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Stripe-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Stripe-Signature", valueList[0], &StripeSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Stripe-Signature: %s", err))
		}

		params.StripeSignature = StripeSignature
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Stripe-Signature is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostWebhookInvoicePaid(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/customer", wrapper.GetCustomer)
	router.PATCH(baseURL+"/customer", wrapper.PatchCustomer)
	router.POST(baseURL+"/customer", wrapper.PostCustomer)
	router.POST(baseURL+"/invoice", wrapper.PostInvoice)
	router.GET(baseURL+"/list/checkout-sessions", wrapper.GetCheckoutSessions)
	router.GET(baseURL+"/list/invoices", wrapper.GetInvoices)
	router.POST(baseURL+"/webhook/invoice-paid", wrapper.PostWebhookInvoicePaid)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
